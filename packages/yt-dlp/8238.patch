From 7d04b5f3bcbf441be7f0b90e9b89e20267891c9d Mon Sep 17 00:00:00 2001
From: coletdjnz <coletdjnz@protonmail.com>
Date: Sat, 30 Sep 2023 10:23:08 +1300
Subject: [PATCH 1/2] Raise a warning for incomplete data by default

---
 README.md                   |  1 +
 yt_dlp/extractor/youtube.py | 91 +++++++++++++++++++------------------
 2 files changed, 48 insertions(+), 44 deletions(-)

diff --git a/README.md b/README.md
index 7bf44657219..8038edaa3f4 100644
--- a/README.md
+++ b/README.md
@@ -1809,6 +1809,7 @@ The following extractors use this feature:
 * `formats`: Change the types of formats to return. `dashy` (convert HTTP to DASH), `duplicate` (identical content but different URLs or protocol; includes `dashy`), `incomplete` (cannot be downloaded completely - live dash and post-live m3u8)
 * `innertube_host`: Innertube API host to use for all API requests; e.g. `studio.youtube.com`, `youtubei.googleapis.com`. Note that cookies exported from one subdomain will not work on others
 * `innertube_key`: Innertube API key to use for all API requests
+* `raise_incomplete_data`: `Incomplete Data` error should raise an error instead of a warning.
 
 #### youtubetab (YouTube playlists, channels, feeds, etc.)
 * `skip`: One or more of `webpage` (skip initial webpage download), `authcheck` (allow the download of playlists requiring authentication when no initial webpage is downloaded. This may cause unwanted behavior, see [#1122](https://github.com/yt-dlp/yt-dlp/pull/1122) for more details)
diff --git a/yt_dlp/extractor/youtube.py b/yt_dlp/extractor/youtube.py
index a39d17cf114..c1b6a6bcb2a 100644
--- a/yt_dlp/extractor/youtube.py
+++ b/yt_dlp/extractor/youtube.py
@@ -941,54 +941,57 @@ def _parse_time_text(self, text):
     def _extract_response(self, item_id, query, note='Downloading API JSON', headers=None,
                           ytcfg=None, check_get_keys=None, ep='browse', fatal=True, api_hostname=None,
                           default_client='web'):
-        for retry in self.RetryManager():
-            try:
-                response = self._call_api(
-                    ep=ep, fatal=True, headers=headers,
-                    video_id=item_id, query=query, note=note,
-                    context=self._extract_context(ytcfg, default_client),
-                    api_key=self._extract_api_key(ytcfg, default_client),
-                    api_hostname=api_hostname, default_client=default_client)
-            except ExtractorError as e:
-                if not isinstance(e.cause, network_exceptions):
-                    return self._error_or_warning(e, fatal=fatal)
-                elif not isinstance(e.cause, HTTPError):
-                    retry.error = e
-                    continue
+        for icr_retry in self.RetryManager(
+            fatal=self._configuration_arg('raise_incomplete_data', [False], ie_key=YoutubeIE)[0] is not False
+        ):
+            for retry in self.RetryManager():
+                try:
+                    response = self._call_api(
+                        ep=ep, fatal=True, headers=headers,
+                        video_id=item_id, query=query, note=note,
+                        context=self._extract_context(ytcfg, default_client),
+                        api_key=self._extract_api_key(ytcfg, default_client),
+                        api_hostname=api_hostname, default_client=default_client)
+                except ExtractorError as e:
+                    if not isinstance(e.cause, network_exceptions):
+                        return self._error_or_warning(e, fatal=fatal)
+                    elif not isinstance(e.cause, HTTPError):
+                        retry.error = e
+                        continue
 
-                first_bytes = e.cause.response.read(512)
-                if not is_html(first_bytes):
-                    yt_error = try_get(
-                        self._parse_json(
-                            self._webpage_read_content(e.cause.response, None, item_id, prefix=first_bytes) or '{}', item_id, fatal=False),
-                        lambda x: x['error']['message'], str)
-                    if yt_error:
-                        self._report_alerts([('ERROR', yt_error)], fatal=False)
-                # Downloading page may result in intermittent 5xx HTTP error
-                # Sometimes a 404 is also recieved. See: https://github.com/ytdl-org/youtube-dl/issues/28289
-                # We also want to catch all other network exceptions since errors in later pages can be troublesome
-                # See https://github.com/yt-dlp/yt-dlp/issues/507#issuecomment-880188210
-                if e.cause.status not in (403, 429):
-                    retry.error = e
-                    continue
-                return self._error_or_warning(e, fatal=fatal)
+                    first_bytes = e.cause.response.read(512)
+                    if not is_html(first_bytes):
+                        yt_error = try_get(
+                            self._parse_json(
+                                self._webpage_read_content(e.cause.response, None, item_id, prefix=first_bytes) or '{}', item_id, fatal=False),
+                            lambda x: x['error']['message'], str)
+                        if yt_error:
+                            self._report_alerts([('ERROR', yt_error)], fatal=False)
+                    # Downloading page may result in intermittent 5xx HTTP error
+                    # Sometimes a 404 is also recieved. See: https://github.com/ytdl-org/youtube-dl/issues/28289
+                    # We also want to catch all other network exceptions since errors in later pages can be troublesome
+                    # See https://github.com/yt-dlp/yt-dlp/issues/507#issuecomment-880188210
+                    if e.cause.status not in (403, 429):
+                        retry.error = e
+                        continue
+                    return self._error_or_warning(e, fatal=fatal)
 
-            try:
-                self._extract_and_report_alerts(response, only_once=True)
-            except ExtractorError as e:
-                # YouTube servers may return errors we want to retry on in a 200 OK response
-                # See: https://github.com/yt-dlp/yt-dlp/issues/839
-                if 'unknown error' in e.msg.lower():
-                    retry.error = e
+                try:
+                    self._extract_and_report_alerts(response, only_once=True)
+                except ExtractorError as e:
+                    # YouTube servers may return errors we want to retry on in a 200 OK response
+                    # See: https://github.com/yt-dlp/yt-dlp/issues/839
+                    if 'unknown error' in e.msg.lower():
+                        retry.error = e
+                        continue
+                    return self._error_or_warning(e, fatal=fatal)
+                # Youtube sometimes sends incomplete data
+                # See: https://github.com/ytdl-org/youtube-dl/issues/28194
+                if not traverse_obj(response, *variadic(check_get_keys)):
+                    icr_retry.error = ExtractorError('Incomplete data received', expected=True)
                     continue
-                return self._error_or_warning(e, fatal=fatal)
-            # Youtube sometimes sends incomplete data
-            # See: https://github.com/ytdl-org/youtube-dl/issues/28194
-            if not traverse_obj(response, *variadic(check_get_keys)):
-                retry.error = ExtractorError('Incomplete data received', expected=True)
-                continue
 
-            return response
+                return response
 
     @staticmethod
     def is_music_url(url):

From 734514992e5ebc014421a6a4afe36383cf0144ad Mon Sep 17 00:00:00 2001
From: coletdjnz <coletdjnz@protonmail.com>
Date: Sat, 30 Sep 2023 10:29:05 +1300
Subject: [PATCH 2/2] fix variable name

---
 yt_dlp/extractor/youtube.py | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/yt_dlp/extractor/youtube.py b/yt_dlp/extractor/youtube.py
index c1b6a6bcb2a..e4f4dda1b4b 100644
--- a/yt_dlp/extractor/youtube.py
+++ b/yt_dlp/extractor/youtube.py
@@ -941,7 +941,7 @@ def _parse_time_text(self, text):
     def _extract_response(self, item_id, query, note='Downloading API JSON', headers=None,
                           ytcfg=None, check_get_keys=None, ep='browse', fatal=True, api_hostname=None,
                           default_client='web'):
-        for icr_retry in self.RetryManager(
+        for icd_retry in self.RetryManager(
             fatal=self._configuration_arg('raise_incomplete_data', [False], ie_key=YoutubeIE)[0] is not False
         ):
             for retry in self.RetryManager():
@@ -988,7 +988,7 @@ def _extract_response(self, item_id, query, note='Downloading API JSON', headers
                 # Youtube sometimes sends incomplete data
                 # See: https://github.com/ytdl-org/youtube-dl/issues/28194
                 if not traverse_obj(response, *variadic(check_get_keys)):
-                    icr_retry.error = ExtractorError('Incomplete data received', expected=True)
+                    icd_retry.error = ExtractorError('Incomplete data received', expected=True)
                     continue
 
                 return response
